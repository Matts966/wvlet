package flow.standard

type string:
  def to_int: int = sql"cast({this} as bigint)"
  def to_long: long = sql"cast({this} as bigint)"
  def to_float: float = sql"cast({this} as double)"
  def to_double: double = sql"cast({this} as double)"
  def to_boolean: boolean = sql"cast({this} as boolean)"

  -- if the string is null, return the default value
  def or_else(other:string): string = sql"coalesce({this},{other})"

  def +(other:string): string = sql"{this} || {other}"
  def length: int = sql"length({this})"
  def trim: string = sql"trim({this})"

  def substring(start:int,end:int): string = sql"substring({this},{start},{end})"
end

-- Using query engine specific dialects
type string in duckdb:
  def substring(start:int): string = sql"substring({this},{start},strlen({this}))"
  def regexp_like(pattern:string): boolean = sql"regexp_matches({this},{pattern})"
end


type string in trino:
  def substring(start:int, end:int): string = sql"substring({this},{start},{end})"
  def regexp_like(pattern:string): boolean = sql"regexp_like({this},{pattern})"
end

